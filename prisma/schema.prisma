// ---------- Generator & datasource ----------
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ---------- Enums ----------
enum Role {
  ADMIN
  USER
}

enum ReadingStatus {
  WANT_TO_READ
  READING
  READ
  ABANDONED
}

enum GenreSlug {
  FANTASY
  SCIENCE_FICTION
  THRILLER
  ROMANCE
  NON_FICTION
  HORROR
  MYSTERY
  HISTORY
  BIOGRAPHY
  POETRY
  DRAMA
  ADVENTURE
  CLASSICS
  CHILDREN
  YOUNG_ADULT
  SELF_HELP
  HEALTH
  TECHNOLOGY
  PHILOSOPHY
  RELIGION
  ART
  TRAVEL
  SATIRE
  GOTHIC
  DYSTOPIA
  MEMOIR
  CRIME
  DETECTIVE
  ESSAY
  HUMOR
  COOKING
  BUSINESS
  EDUCATION
  PSYCHOLOGY
  POLITICS
  SPORT
  TRUE_CRIME
  FAIRY_TALES
  WESTERN
  LGBTQ
  CULTURE
  COMICS
  GRAPHIC_NOVEL
  ESSAYS
  LITERARY_FICTION
  SPIRITUALITY
  ENVIRONMENT
  MUSIC
  CLASSIC_FICTION
  CONTEMPORARY_FICTION
  URBAN_FANTASY
  HISTORICAL_FICTION
  MAGICAL_REALISM
  SHORT_STORIES
  FANFICTION
  SCIENCE
  ASTRONOMY
  MATHEMATICS
  ECONOMICS
  PARENTING
  MINDFULNESS
  PRODUCTIVITY
  PERSONAL_DEVELOPMENT
  ANTHROPOLOGY
  SOCIOLOGY
  GENDER_STUDIES
  RACE_AND_ETHNICITY
  DESIGN
  PHOTOGRAPHY
  ARCHITECTURE
  FASHION
  GAMEBOOK
  ZINES
  MYTHOLOGY
  FOLKLORE
  AUTOBIOGRAPHY
  ANIMALS
  LANGUAGE
}

enum MediaFormat {
  HARDCOVER
  PAPERBACK
  EBOOK
  AUDIOBOOK
}

enum EditionContributorRole {
  TRANSLATOR
  ILLUSTRATOR
  EDITOR
  NARRATOR
  PREFACE_AUTHOR
}

// ---------- Core people/publishers ----------
model Person {
  id        String   @id @default(uuid())
  name      String
  sortName  String?
  aliases   String[] @default([])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  authoredBooks        BookAuthor[]
  editionContributions EditionContributor[]

  @@index([name])
  @@index([sortName])
}

model Publisher {
  id   String @id @default(uuid())
  name String @unique

  editions Edition[]
}

// ---------- User ----------
model User {
  id        String   @id @default(uuid())
  email     String   @unique
  name      String?
  avatarUrl String?
  createdAt DateTime @default(now())

  role Role @default(USER)

  books         UserBook[]
  comments      Comment[]
  CommentRating CommentRating[]
  userRatings   UserRating[]
}

// ---------- Books & Editions ----------
model Book {
  id                   String    @id @default(uuid())
  title                String
  description          String?
  addedAt              DateTime  @default(now())
  firstPublicationDate DateTime?

  averageRating Float? @default(0)
  ratingCount   Int?   @default(0)

  // autorzy (kolejność przez "order")
  authors BookAuthor[]

  // wydania
  editions Edition[]

  // pozostałe relacje z Twojego projektu
  genres      BookGenre[]
  comments    Comment[]
  userBook    UserBook[]
  userRatings UserRating[]
}

model BookAuthor {
  bookId   String
  personId String
  order    Int?

  book   Book   @relation(fields: [bookId], references: [id], onDelete: Cascade)
  person Person @relation(fields: [personId], references: [id], onDelete: Cascade)

  @@id([bookId, personId])
  @@index([personId])
}

model Edition {
  id     String @id @default(uuid())
  bookId String
  book   Book   @relation(fields: [bookId], references: [id], onDelete: Cascade)

  // identyfikatory (opcjonalne – ale jeśli podasz, to unikalne)
  isbn13 String? @unique
  isbn10 String? @unique

  language    String
  publisherId String?
  publisher   Publisher? @relation(fields: [publisherId], references: [id])

  publicationDate DateTime?
  pageCount       Int?
  format          MediaFormat?
  coverUrl        String?
  coverPublicId   String?

  // nadpisania metadanych (opcjonalnie)
  title    String?
  subtitle String?

  // role na poziomie wydania (tłumacz/ilustrator/lektor/…)
  contributors EditionContributor[]

  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  UserBook  UserBook[]

  @@index([bookId])
  @@index([language])
  @@index([publicationDate])
  @@index([bookId, language, publicationDate])
}

model EditionContributor {
  editionId String
  personId  String
  role      EditionContributorRole
  order     Int?

  edition Edition @relation(fields: [editionId], references: [id], onDelete: Cascade)
  person  Person  @relation(fields: [personId], references: [id], onDelete: Cascade)

  @@id([editionId, personId, role])
  @@index([personId])
}

// ---------- Genres ----------
model Genre {
  id           String             @id @default(uuid())
  slug         GenreSlug          @unique
  books        BookGenre[]
  translations GenreTranslation[]
}

model GenreTranslation {
  id      String @id @default(uuid())
  genreId String
  genre   Genre  @relation(fields: [genreId], references: [id])

  language String
  name     String

  @@unique([genreId, language])
}

model BookGenre {
  bookId  String
  genreId String

  book  Book  @relation(fields: [bookId], references: [id], onDelete: Cascade)
  genre Genre @relation(fields: [genreId], references: [id])

  @@id([bookId, genreId])
}

// ---------- Social: ratings & comments ----------
model UserRating {
  userId    String
  bookId    String
  rating    Int      @db.SmallInt
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  book Book @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@id([bookId, userId])
  @@index([bookId])
  @@index([userId])
}

model Comment {
  id       String          @id @default(uuid())
  content  String
  addedAt  DateTime        @default(now())
  authorId String
  author   User            @relation(fields: [authorId], references: [id])
  parentId String?
  parent   Comment?        @relation("CommentReplies", fields: [parentId], references: [id])
  replies  Comment[]       @relation("CommentReplies")
  ratings  CommentRating[]
  Book     Book            @relation(fields: [bookId], references: [id], onDelete: Cascade)
  bookId   String
}

model CommentRating {
  id        String  @id @default(uuid())
  commentId String
  comment   Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  value Int // +1 = upvote, -1 = downvote

  @@unique([commentId, userId])
}

// ---------- User ↔ Book ----------
model UserBook {
  userId        String
  bookId        String
  editionId     String? // opcjonalnie: wybrane wydanie użytkownika
  readingStatus ReadingStatus @default(WANT_TO_READ)
  addedAt       DateTime      @default(now())
  note          String?

  User    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  book    Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)
  edition Edition? @relation(fields: [editionId], references: [id], onDelete: SetNull)

  @@id([bookId, userId]) // jeden wpis per dzieło na użytkownika
  @@index([editionId])
  @@index([userId, addedAt])
}
